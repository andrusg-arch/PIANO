<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Piano Virtual — Andrés Giraldo (Blacks fixed)</title>
<style>
  /* Evitar copiar/pegar en nombres de las notas */
.white .lbl, .black .lbl {
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  -moz-user-select: none;
  -webkit-touch-callout: none; /* iOS: evita el menú de copiar/pegar */
  pointer-events: none;        /* el texto no captura el toque, la tecla sí */
}

/* Quitar highlight táctil molesto */
.white, .black {
  -webkit-tap-highlight-color: transparent;
}
:root{
  --bg:#071126; --panel:#0b2330; --muted:#9fb0bd; --accent:#00d4b4;
  --white:#fffdf6; --white-edge:#d4cec4; --black:#0b0f12;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#021018);color:#e6f4f2;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
.app{max-width:1200px;margin:18px auto;padding:14px;display:flex;flex-direction:column;gap:12px}
.header{display:flex;justify-content:space-between;align-items:start;gap:12px}
h1{margin:0;font-size:20px}
.subtitle{margin:4px 0 0;color:var(--muted);font-size:13px}
.controls{display:flex;gap:10px;flex-wrap:wrap;background:var(--panel);padding:10px;border-radius:12px}
.control-group{display:flex;flex-direction:column;gap:6px;color:var(--muted);font-size:13px}
select,input[type=range],button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px;border-radius:8px}
button.primary{background:var(--accent);color:#012;border:none;font-weight:700}
.keyboard-wrap{background:linear-gradient(180deg,#041427,#021018);padding:12px;border-radius:12px}
.keyboard{position:relative;width:100%;overflow-x:auto;border-radius:8px;padding:8px}
.white-keys{display:flex;gap:0;align-items:flex-end;height:320px;position:relative}
.white{width:64px;height:100%;background:var(--white);border-left:1px solid var(--white-edge);border-right:1px solid var(--white-edge);border-bottom:12px solid #ddd;border-radius:6px 6px 0 0;position:relative;z-index:1;display:flex;align-items:flex-end;justify-content:center;cursor:pointer}
.white .lbl{font-size:11px;color:#222;padding:6px}
.white.pressed{background:linear-gradient(180deg,#fff8d6,#fff3c9);transform:translateY(4px)}
.black-container{position:absolute;top:8px;left:8px;right:8px;bottom:0;pointer-events:none} /* container for black keys - absolute over whites */
.black{position:absolute;width:19px;height:58%;background:var(--black);border-radius:0 0 6px 6px;z-index:3;display:flex;align-items:flex-end;justify-content:center;color:#fff;cursor:pointer;pointer-events:auto;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
.black .lbl{font-size:11px;padding:6px}
.black.pressed{background:#222;transform:translateY(4px)}
.legend{display:flex;justify-content:space-between;color:var(--muted);font-size:13px;margin-top:8px}
.footer{margin-top:8px;color:var(--muted);font-size:13px;text-align:center}
.social a{color:var(--accent);text-decoration:none;margin:0 8px}
@media (max-width:900px){ .white{width:48px} .black{width:19px} .white-keys{height:260px} }
@media (max-width:560px){ .white{width:40px} .white-keys{height:220px} .controls{gap:8px} }
/* --- Ear Trainer UI --- */
.ear-trainer-wrap { margin-top:10px; border-radius:10px; padding:8px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); display:block; }
#toggleEarBtn { background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;cursor:pointer;margin-bottom:8px; }
#earTrainerPanel { display:none; padding:8px 6px; border-radius:8px; }
.ear-controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
.ear-controls .counters { color:var(--muted); font-size:13px; margin-left:8px; }
.ear-keys { display:flex; flex-wrap:wrap; gap:6px; }
.ear-btn { min-width:44px; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; cursor:pointer; font-weight:700; }
.interval-btn {
  min-width:44px; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; cursor:pointer; font-weight:700;
}
.interval-btn.correct { background:#22c55e; color:#012; border-color:rgba(0,0,0,0.12); }
.interval-btn.wrong { background:#ef4444; color:#fff; border-color:rgba(0,0,0,0.12); }
@media (max-width:560px){ .interval-btn{ min-width:38px; padding:6px 8px } }
  .ear-btn.correct { background:#22c55e; color:#012; border-color:rgba(0,0,0,0.12); }
.ear-btn.wrong { background:#ef4444; color:#fff; border-color:rgba(0,0,0,0.12); }
.ear-actions { margin-left:auto; display:flex; gap:8px; }
@media (max-width:560px){ .ear-btn{ min-width:38px; padding:6px 8px } }
/* --- Zoom Piano --- */
#keyboard {
  transform-origin: left center;
  transition: transform 0.2s ease;
               }
/* --- Staff (pentagrama) --- */
#staffCanvas { box-shadow: 0 6px 18px rgba(0,0,0,0.25); background: transparent; }
</style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div>
        <h1>🎹 Piano Virtual</h1>
        <div class="subtitle">5 octavas • Polifonía • Sustain • Trainers</div>
      </div>
      <div style="text-align:right">
        <div class="small">Diseño y código: <strong>Andrés Giraldo</strong></div>
        <div class="small social">Instagram: <a href="https://instagram.com/andres._.sgiraldo" target="_blank">@andres._.sgiraldo</a> • TikTok: <a href="https://tiktok.com/@andru_gs" target="_blank">@andru_gs</a></div>
      </div>
    </div>

    <div class="controls" role="region" aria-label="Controles">
      
      <div class="control-group"><label class="small">Volumen</label><input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.88"></div>
      <div class="control-group">
  <label class="small">Zoom</label>
  <input id="zoomRange" type="range" min="0.5" max="2" step="0.1" value="1">
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center"><button id="sustainBtn">Sustain: off</button><button id="resetBtn" class="primary">Reset</button></div>
    </div>
<!-- Pentagrama (pequeño, no molesta) -->
<canvas id="staffCanvas" width="520" height="180" style="display:block;margin:8px auto 12px;max-width:520px;width:100%;height:auto;border-radius:8px;"></canvas>
    <!-- EAR TRAINER (desplegable) -->
<!-- EAR TRAINER (desplegable) -->
<div class="ear-trainer-wrap" style="display:flex;gap:8px;align-items:flex-start;">
  <div style="flex:1">
    <button id="toggleEarBtn" aria-expanded="false">Ear Trainer ▸</button>
    <div id="earTrainerPanel" aria-hidden="true">
      <div class="ear-controls">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="playTargetBtn" class="ear-action">🔊 Play</button>
          <button id="repeatBtn" class="ear-action">Repetir</button>
          <button id="nextBtn" class="ear-action">Siguiente</button>
        </div>
        <div class="ear-actions">
          <div class="counters">Correctas: <strong id="correctCount">0</strong> &nbsp;|&nbsp; Incorrectas: <strong id="wrongCount">0</strong></div>
        </div>
      </div>

      <div class="ear-keys" role="group" aria-label="Opciones de nota">
        <button class="ear-btn" data-note="C">C</button>
        <button class="ear-btn" data-note="C#">C♯/D♭</button>
        <button class="ear-btn" data-note="D">D</button>
        <button class="ear-btn" data-note="D#">D♯/E♭</button>
        <button class="ear-btn" data-note="E">E</button>
        <button class="ear-btn" data-note="F">F</button>
        <button class="ear-btn" data-note="F#">F♯/G♭</button>
        <button class="ear-btn" data-note="G">G</button>
        <button class="ear-btn" data-note="G#">G♯/A♭</button>
        <button class="ear-btn" data-note="A">A</button>
        <button class="ear-btn" data-note="A#">A♯/B♭</button>
        <button class="ear-btn" data-note="B">B</button>
      </div>
    </div>
  </div>

  <!-- INTERVAL TRAINER al lado -->
  <div style="flex:1">
    <button id="toggleIntervalBtn" aria-expanded="false">Interval Trainer ▸</button>
    <div id="intervalTrainerPanel" aria-hidden="true">
      <div class="ear-controls">
        <div style="display:flex;gap:8px;align-items:center">
          <button id="playIntervalBtn" class="ear-action">🔊 Play</button>
          <button id="repeatIntervalBtn" class="ear-action">Repetir</button>
          <button id="nextIntervalBtn" class="ear-action">Siguiente</button>
        </div>
        <div class="ear-actions">
          <div class="counters">Correctas: <strong id="intervalCorrectCount">0</strong> &nbsp;|&nbsp; Incorrectas: <strong id="intervalWrongCount">0</strong></div>
        </div>
      </div>

      <div class="ear-keys" role="group" aria-label="Opciones de intervalo">
        <button class="ear-btn" data-interval="unison">Unísono</button>
        <button class="ear-btn" data-interval="minor2">2m</button>
        <button class="ear-btn" data-interval="major2">2M</button>
        <button class="ear-btn" data-interval="minor3">3m</button>
        <button class="ear-btn" data-interval="major3">3M</button>
        <button class="ear-btn" data-interval="perfect4">4P</button>
        <button class="ear-btn" data-interval="tritone">TT</button>
        <button class="ear-btn" data-interval="perfect5">5P</button>
        <button class="ear-btn" data-interval="minor6">6m</button>
        <button class="ear-btn" data-interval="major6">6M</button>
        <button class="ear-btn" data-interval="minor7">7m</button>
        <button class="ear-btn" data-interval="major7">7M</button>
        <button class="ear-btn" data-interval="octave">8P</button>
      </div>
    </div>
  </div>
  </div>
<!-- /INTERVAL TRAINER -->
    <div class="keyboard-wrap" role="application" aria-label="Piano">
      <div id="keyboard" class="keyboard" tabindex="0" aria-label="Piano keyboard">
        <div id="whiteContainer" class="white-keys" aria-hidden="false"></div>
        <div id="blackContainer" class="black-container" aria-hidden="false"></div>
      </div>
      <div class="legend"><div>Rango: <strong>C2 → B6</strong> (5 octavas)</div><div class="small">Barra espacio = sustain • Teclado Q..P / A..L / Z..M</div></div>
    </div>

    <div class="footer">página de prueba <code>piano_andres_black_fixed.html</code>. Para codigo html.</div>
  </div>

<script>
/* Fixed: black keys on separate container and positioned relative to white keys.
   Keeps previous features. */

const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
const masterGain = audioCtx.createGain();
masterGain.gain.value = 2.0;
masterGain.connect(audioCtx.destination);

const reverbGain = audioCtx.createGain();
const delay = audioCtx.createDelay();
const feedback = audioCtx.createGain();
const reverbLP = audioCtx.createBiquadFilter();
delay.delayTime.value = 0.08;
feedback.gain.value = 0.35;
reverbLP.type = 'lowpass';
reverbLP.frequency.value = 3000;
reverbGain.gain.value = 0.12;

// connect reverb chain and master
reverbGain.connect(delay);
delay.connect(feedback);
feedback.connect(reverbLP);
reverbLP.connect(masterGain);
masterGain.disconnect();
masterGain.connect(audioCtx.destination);
masterGain.connect(reverbGain);

// UI refs
const whiteContainer = document.getElementById('whiteContainer');
const blackContainer = document.getElementById('blackContainer');
const keyboardEl = document.getElementById('keyboard');
const masterVol = document.getElementById('masterVol');
const sustainBtn = document.getElementById('sustainBtn');
const resetBtn = document.getElementById('resetBtn');
const zoomRange = document.getElementById("zoomRange");

zoomRange.addEventListener("input", () => {
  const scale = parseFloat(zoomRange.value);
  keyboardEl.style.transform = `scale(${scale})`;
});
masterVol.addEventListener('input', ()=> masterGain.gain.value = parseFloat(masterVol.value));
document.addEventListener('pointerdown', function resumeAudio(){ if(audioCtx.state === 'suspended') audioCtx.resume(); document.removeEventListener('pointerdown', resumeAudio); });
// evitar menú contextual y selección por largo toque
document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('selectstart', e => e.preventDefault());
// notes build
const semitones = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const notes = [];
const startOct = 2;
const octCount = 5; // C2..B6
for(let o = startOct; o < startOct + octCount; o++){
  for(let i=0;i<12;i++){
    const name = semitones[i] + o;
    const midi = (o + 1) * 12 + i;
    const freq = 440 * Math.pow(2, (midi - 69)/12);
    notes.push({name,midi,freq,isSharp: semitones[i].includes('#'), semi:i});
  }
}

// create whites
whiteContainer.innerHTML = '';
const whiteEls = [];
for(let i=0;i<notes.length;i++){
  if(!notes[i].isSharp){
    const w = document.createElement('div');
    w.className = 'white';
    w.dataset.semiIndex = i; // semitone index
    w.dataset.index = i;
    w.dataset.note = notes[i].name;
    const lbl = document.createElement('div'); lbl.className='lbl'; lbl.textContent = notes[i].name;
    w.appendChild(lbl);
    whiteContainer.appendChild(w);
    whiteEls.push(w);
  }
}

// create blacks into blackContainer (absolute)
blackContainer.innerHTML = '';
for(let i=0;i<notes.length;i++){
  if(notes[i].isSharp){
    const b = document.createElement('div');
    b.className = 'black';
    b.dataset.semiIndex = i;
    b.dataset.index = i;
    b.dataset.note = notes[i].name;
    const lbl = document.createElement('div'); lbl.className='lbl'; lbl.textContent = notes[i].name;
    b.appendChild(lbl);
    blackContainer.appendChild(b);
  }
}

// position blacks relative to whites
function positionBlackKeys(){
  const whites = Array.from(whiteContainer.children);
  if(whites.length === 0) return;
  const blackEls = Array.from(blackContainer.children);
  const whiteWidth = whites[0].getBoundingClientRect().width;
  // set blackContainer left = whiteContainer offsetLeft (both inside keyboard)
  const wcRect = whiteContainer.getBoundingClientRect();
  const kbRect = keyboardEl.getBoundingClientRect();
  const offsetLeft = whiteContainer.offsetLeft; // relative to keyboardEl
  // position each black:
  blackEls.forEach(b=>{
    const semiIdx = parseInt(b.dataset.semiIndex,10);
    // count whites before this semitone
    const whitesBefore = notes.slice(0, semiIdx).filter(n=>!n.isSharp).length;
    // the black should be between whitesBefore-1 and whitesBefore
    let left = 0;
    if(whitesBefore > 0){
      // reference white to the left of the gap
      const leftWhite = whites[whitesBefore-1];
      left = leftWhite.offsetLeft + leftWhite.offsetWidth - (b.offsetWidth/2);
    } else {
      left = whites[0].offsetLeft - (b.offsetWidth/2);
    }
    b.style.left = Math.round(left) + 'px';
  });
}
setTimeout(positionBlackKeys, 80);
window.addEventListener('resize', ()=> setTimeout(positionBlackKeys, 80));

// ---------- Audio con samples ----------
const activeVoices = new Map();
const sampleMap = {};
const baseNotes = ["C2","C3","C4","C5","C6"];

// --- Visual: marcar / desmarcar tecla en pantalla ---
function markKey(idx, pressed) {
  // busca la tecla (blanca o negra) dentro del keyboard
  const el = keyboardEl.querySelector('[data-index="'+idx+'"]');
  if(!el) return;
  if (pressed) el.classList.add('pressed');
  else el.classList.remove('pressed');
  }
  function clearAllPressed(){
  const all = keyboardEl.querySelectorAll('.pressed');
  all.forEach(el => el.classList.remove('pressed'));
}
window.addEventListener('mouseup', clearAllPressed);
window.addEventListener('touchend', clearAllPressed);
window.addEventListener('blur', clearAllPressed); // cuando la ventana pierde foco
// Cargar samples en memoria
async function loadSamples() {
  for (let note of baseNotes) {
    try {
      const resp = await fetch(`samples/${note}.mp3`);
      const arr = await resp.arrayBuffer();
      sampleMap[note] = await audioCtx.decodeAudioData(arr);
    } catch (err) {
      console.error("❌ Error cargando sample", note, err);
    }
  }
  console.log("✅ Samples cargados:", Object.keys(sampleMap));
}
loadSamples();

// Escoger el sample correcto para cada nota (según su octava)
function getSampleForNote(noteName) {
  const oct = parseInt(noteName.slice(-1));
  const base = "C" + oct;
  if (sampleMap[base]) return base;
  // fallback si no hay sample
  return "C4";
}
// --------- PENTAGRAMA (staff) ---------
const staffCanvas = document.getElementById('staffCanvas');
const staffCtx = staffCanvas ? staffCanvas.getContext('2d') : null;

  // mantenemos lista de notas que están sonando en el pentagrama
let activeStaffNotes = [];
// nombres de notas en orden (do–si)
const noteNames = ["C","D","E","F","G","A","B"];

// Función auxiliar: convierte número MIDI a nombre de nota
function midiToNoteName(midi) {
  const note = midi % 12;
  const octave = Math.floor(midi / 12) - 1;
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  return names[note] + octave;
}

<!-- 🔽 Reemplaza solo desde la función drawStaff hasta midiToStaffY -->
// Dibujar las líneas del pentagrama
function drawStaff() {
  if(!staffCtx) return;
  const ctx = staffCtx;
  ctx.clearRect(0,0,staffCanvas.width, staffCanvas.height);
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#fff';
  ctx.fillStyle = '#fff';
  ctx.font = "28px serif";

  const left = 40;
  const right = staffCanvas.width - 20;
  const lineGap = 12;

  // Pentagrama superior (clave de sol)
  const topY = 40;
  for(let i=0;i<5;i++){
    const y = topY + i*lineGap;
    ctx.beginPath();
    ctx.moveTo(left,y);
    ctx.lineTo(right,y);
    ctx.stroke();
  }

  // Pentagrama inferior (clave de fa)
  const bottomY = 120;
  for(let i=0;i<5;i++){
    const y = bottomY + i*lineGap;
    ctx.beginPath();
    ctx.moveTo(left,y);
    ctx.lineTo(right,y);
    ctx.stroke();
  }

  // Claves
  ctx.fillText("𝄞", 10, topY+25);   // clave de sol
  ctx.fillText("𝄢", 10, bottomY+25); // clave de fa
}

// Calcula la posición Y de una nota en el pentagrama
function midiToStaffY(midi) {
  const step = 6; // cada paso diatónico equivale a 6px

  // referencia en clave de sol: G4 en la segunda línea
  const solRefMidi = 67; 
  const solRefY = 40 + (4-1)*12; // línea 2 = topY + lineGap*1

  // referencia en clave de fa: F3 en la cuarta línea
  const faRefMidi = 53;
  const faRefY = 120 + (3*12);

  let referenceMidi, referenceY;
  if (midi >= 60) { // de C4 hacia arriba → clave de sol
    referenceMidi = solRefMidi;
    referenceY = solRefY;
  } else {          // de B3 hacia abajo → clave de fa
    referenceMidi = faRefMidi;
    referenceY = faRefY;
  }

  // diferencia en semitonos con respecto a la nota de referencia
  const delta = midi - referenceMidi;
  let y = referenceY - delta * (step * 7 / 12);

  // ✅ Ajuste especial: subir C2..B3 dos líneas (24px) más arriba
  if (midi >= 36 && midi <= 59) {
    y -= 24;
  }

  return y;
  }

// Dibuja una nota en el pentagrama
function drawActiveStaffNotes() {
  if (!staffCtx) return;
  // limpiar el pentagrama antes de dibujar
  staffCtx.clearRect(0, 0, staffCanvas.width, staffCanvas.height);

  // volver a dibujar el pentagrama vacío
  drawStaff();

  const ctx = staffCtx;
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.font = "20px serif";

  const xCenter = 140;   // centro donde se dibujan las notas
  const spacing = 26;    // espacio entre cabezas si hay varias

  const notesToDraw = Array.from(new Set(activeStaffNotes)).sort((a,b)=>a-b);
  const count = notesToDraw.length;

  const topY = 40;
  const bottomY = 120;
  const lineGap = 12;
  const bottomLineY = bottomY + 4 * lineGap;

  notesToDraw.forEach((midi, i) => {
    const offsetIndex = i - (count - 1) / 2;
    const x = xCenter + offsetIndex * spacing;
    const y = midiToStaffY(midi);

    // cabeza de nota
    ctx.beginPath();
    ctx.ellipse(x, y, 9, 6, Math.PI * 0.1, 0, Math.PI * 2);
    ctx.fill();

    // alteraciones
    const noteName = midiToNoteName(midi);
    if (noteName.includes("#")) ctx.fillText("♯", x - 18, y + 5);
    if (noteName.includes("b")) ctx.fillText("♭", x - 18, y + 5);

    // líneas adicionales
    if (y < topY - 6 || y > bottomLineY + 6) {
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x + 12, y);
      ctx.stroke();
    }

    // línea para Do central (C4)
    if (midi === 60) {
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x + 12, y);
      ctx.stroke();
    }
  });
  }

// Dibuja el pentagrama vacío al inicio
drawStaff();
function noteOn(idx, velocity = 1) {
  const n = notes[idx];
  if (!n) return;

  const now = audioCtx.currentTime;

  // Siempre usar samples
  const sampleKey = getSampleForNote(n.name);
  const buffer = sampleMap[sampleKey];
  if (buffer) {
    const sampleFreq = notes.find(x => x.name === sampleKey).freq;
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.playbackRate.value = n.freq / sampleFreq;

    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(velocity, now);

    src.connect(gain).connect(masterGain);
    src.start(now);

    activeVoices.set(idx, { src, gain, release: 0.2, released: false });
  }

  // Visual + pentagrama
  markKey(idx, true);
  if (!activeStaffNotes.includes(n.midi)) activeStaffNotes.push(n.midi);
  drawActiveStaffNotes();
  }

function noteOff(idx) {
  const midiValue = notes[idx] ? notes[idx].midi : null;

  // 1) QUITAR LA FIGURA DEL PENTAGRAMA INMEDIATAMENTE al soltar
  if (midiValue !== null) {
    activeStaffNotes = activeStaffNotes.filter(m => m !== midiValue);
    drawActiveStaffNotes();
  }

  // 2) Conseguir la voz (si existe) usando la misma clave numérica idx
  const v = activeVoices.get(idx);
  if (!v) {
    // no había voz activa (por ejemplo sample no cargado). Solo desmarcamos la tecla.
    markKey(idx, false);
    return;
  }

  // 3) Si hay sustain y la voz aún no fue marcada como 'released', no la detengas ahora (audio sigue),
  //    pero la figura ya fue retirada visualmente.
  if (sustainOn && !v.released) {
    v.released = true;
    markKey(idx, false);
    return;
  }

  // 4) Si no hay sustain (o ya está marcada released), hacemos fade out y paramos la fuente
  const now = audioCtx.currentTime;
  try {
    v.gain.gain.cancelScheduledValues(now);
    v.gain.gain.linearRampToValueAtTime(0.0001, now + v.release);
    try { v.src.stop(now + v.release + 0.05); } catch(e) {}
  } catch(e) {
    // si algo falla con la rampa/stop, intentamos forzar stop
    try { v.src.stop(); } catch(_) {}
  }

  // borramos el registro una vez terminado el release (para liberar memoria)
  setTimeout(() => {
    activeVoices.delete(idx);
  }, (v.release + 0.12) * 1000);

  markKey(idx, false);
  }

/* -------------------- EAR TRAINER -------------------- */
/* Asegura markKey si no existe (fallback seguro) */
if (typeof markKey === 'undefined') {
  function markKey(idx, pressed) {
    const el = keyboardEl.querySelector('[data-index="'+idx+'"]');
    if(!el) return;
    if (pressed) el.classList.add('pressed'); else el.classList.remove('pressed');
  }
}

/* Estado del entrenador */
const ear = { targetIdx: null, targetName: null, correct: 0, wrong: 0 };

/* DOM refs */
const toggleEarBtn = document.getElementById('toggleEarBtn');
const earPanel = document.getElementById('earTrainerPanel');
const playTargetBtn = document.getElementById('playTargetBtn');
const repeatBtn = document.getElementById('repeatBtn');
const nextBtn = document.getElementById('nextBtn');
const correctCountEl = document.getElementById('correctCount');
const wrongCountEl = document.getElementById('wrongCount');
const earButtons = Array.from(document.querySelectorAll('.ear-btn'));

/* Toggle panel */
toggleEarBtn.addEventListener('click', ()=>{
  const visible = earPanel.style.display === 'block';
  earPanel.style.display = visible ? 'none' : 'block';
  toggleEarBtn.textContent = visible ? 'Ear Trainer ▸' : 'Ear Trainer ▾';
  toggleEarBtn.setAttribute('aria-expanded', !visible);
  earPanel.setAttribute('aria-hidden', visible);
});
const toggleIntervalBtn = document.getElementById('toggleIntervalBtn');
const intervalPanel = document.getElementById('intervalTrainerPanel');
// Inicializar Interval Trainer plegado
intervalPanel.style.display = 'none';
toggleIntervalBtn.textContent = 'Interval Trainer ▸';
toggleIntervalBtn.setAttribute('aria-expanded', false);
intervalPanel.setAttribute('aria-hidden', true);
toggleIntervalBtn.addEventListener('click', ()=>{
  const visible = intervalPanel.style.display === 'block';
  intervalPanel.style.display = visible ? 'none' : 'block';
  toggleIntervalBtn.textContent = visible ? 'Interval Trainer ▸' : 'Interval Trainer ▾';
  toggleIntervalBtn.setAttribute('aria-expanded', !visible);
  intervalPanel.setAttribute('aria-hidden', visible);
});
/* util: limpiar estados visuales de botones */
function clearEarButtons(){
  earButtons.forEach(b => { b.classList.remove('correct','wrong'); b.disabled = false; });
}
function clearIntervalButtons(){
  intervalButtons.forEach(b => {
    b.classList.remove('correct','wrong');
    b.disabled = false;
  });
  }
/* reproducir nota como preview sin tocar activeVoices (no interactúa con sustain) */
function playPreview(idx){
  const n = notes[idx];
  if(!n) return;

  const now = audioCtx.currentTime;
  const sampleKey = getSampleForNote(n.name);

  let src, g;

  if(sampleMap[sampleKey]){
    // sample
    src = audioCtx.createBufferSource();
    src.buffer = sampleMap[sampleKey];
    const sampleFreq = notes.find(x => x.name === sampleKey).freq;
    src.playbackRate.value = n.freq / sampleFreq;

    g = audioCtx.createGain();
    g.gain.setValueAtTime(1.0, now);

    src.connect(g).connect(masterGain);
    src.start(now);

    // Guardamos la voz para que siga sonando
    activeVoices.set(`ear_${idx}`, { src, gain: g, release: 0.3, released: false });
  } else {
    // fallback oscillator
    src = audioCtx.createOscillator();
    g = audioCtx.createGain();
    src.type = 'sine';
    src.frequency.setValueAtTime(n.freq, now);
    g.gain.setValueAtTime(1.0, now);
    src.connect(g).connect(masterGain);
    src.start(now);

    activeVoices.set(`ear_${idx}`, { src, gain: g, release: 0.3, released: false });
  }

  // solo visual
  markKey(idx, true);
  }

/* elegir nota aleatoria y reproducir */
function pickRandomTarget(){
  clearEarButtons();
  const idx = Math.floor(Math.random() * notes.length);
  ear.targetIdx = idx;
  ear.targetName = notes[idx].name.slice(0, -1); // quitar octava
  playPreview(idx, 1.0);
}

/* reproducir objetivo actual (si existe) */
function playTarget(){
  if(ear.targetIdx === null) pickRandomTarget();
  else playPreview(ear.targetIdx, 1.0);
}

/* manejar respuesta del usuario */
function handleGuess(label, buttonEl){
  if(ear.targetIdx === null) return;
  // deshabilitar temporalmente botones para evitar spam
  earButtons.forEach(b=> b.disabled = true);

  const correctLabel = ear.targetName; // ej "C#", "G"
  if(label === correctLabel){
    // acierto
    ear.correct += 1;
    buttonEl.classList.add('correct');
    correctCountEl.textContent = ear.correct;
    // iluminar brevemente la tecla real del piano
    // (buscamos una instancia de esa nota en cualquier octava y la marcamos breve)
    const idx = notes.findIndex(n => n.name.slice(0,-1) === label);
    if(idx >= 0) { markKey(idx, true); setTimeout(()=>markKey(idx,false),300); }
  } else {
    // error
    ear.wrong += 1;
    buttonEl.classList.add('wrong');
    wrongCountEl.textContent = ear.wrong;
    // marcar la correcta en verde
    const correctBtn = earButtons.find(b=> b.dataset.note === correctLabel);
    if(correctBtn) correctBtn.classList.add('correct');
    // iluminar la tecla real
    const idx = notes.findIndex(n => n.name.slice(0,-1) === correctLabel);
    if(idx >= 0) { markKey(idx, true); setTimeout(()=>markKey(idx,false),300); }
  }

  // después de un pequeño delay, permitir avanzar (o el usuario usa 'Siguiente')
  setTimeout(()=> { earButtons.forEach(b=> b.disabled = false); }, 700);
}

/* eventos de los botones de nota */
earButtons.forEach(btn => {
  btn.addEventListener('click', (e) => {
    const label = btn.dataset.note;
    handleGuess(label, btn);
  });
});

/* acciones: play, repeat, next */
playTargetBtn.addEventListener('click', (e) => {
  e.preventDefault();
  playTarget();
});
repeatBtn.addEventListener('click', (e) => {
  e.preventDefault();
  playTarget();
});
nextBtn.addEventListener('click', (e) => {
  e.preventDefault();
  pickRandomTarget();
});

/* inicializar (puedes elegir iniciar con una nota automática si quieres) */
clearEarButtons();
  
// pointer events
let sustainOn = false;
sustainBtn.addEventListener('click', ()=> { sustainOn = !sustainOn; sustainBtn.textContent = 'Sustain: ' + (sustainOn ? 'on' : 'off'); sustainBtn.classList.toggle('primary', sustainOn); if(!sustainOn) releaseAllHeld(); });
// 👉 toma solo los botones del panel de Interval Trainer
const intervalButtons = Array.from(document.querySelectorAll('#intervalTrainerPanel .ear-btn'));
  // mapeo para convertir el nombre que tienes en HTML a semitonos (0..12)
const intervalNameToSemitone = {
  unison: 0, minor2: 1, major2: 2, minor3: 3, major3: 4,
  perfect4: 5, tritone: 6, perfect5: 7, minor6: 8, major6: 9,
  minor7: 10, major7: 11, octave: 12
};
let intervalTarget = null; // variable de estado (si no existe, agrégala)

function pickRandomInterval(){
  clearIntervalButtons(); // limpia colores de la ronda anterior

  const rootIdx = Math.floor(Math.random() * notes.length);
  const semitone = Math.floor(Math.random() * 13); // 0..12
  intervalTarget = { rootIdx, semitone };

  // reproducir: raíz y luego la nota destino
  playPreview(rootIdx, 0.6);
  const targetIdx = Math.min(rootIdx + semitone, notes.length - 1);
  setTimeout(()=> playPreview(targetIdx, 0.6), 650);
  }

function handleIntervalGuessByName(btn) {
  if(!intervalTarget) return;

  // bloquear y limpiar clases
  intervalButtons.forEach(b => { b.disabled = true; b.classList.remove('correct','wrong'); });

  const selectedName = btn.dataset.interval; // ej "minor3"
  const selectedSemitone = intervalNameToSemitone[selectedName];

  if(selectedSemitone === intervalTarget.semitone) {
    btn.classList.add('correct');
    const countEl = document.getElementById('intervalCorrectCount');
    countEl.textContent = parseInt(countEl.textContent) + 1;
  } else {
    btn.classList.add('wrong');
    // marcar correcta en verde
    const correctBtn = intervalButtons.find(b => intervalNameToSemitone[b.dataset.interval] === intervalTarget.semitone);
    if(correctBtn) correctBtn.classList.add('correct');
    const countEl = document.getElementById('intervalWrongCount');
    countEl.textContent = parseInt(countEl.textContent) + 1;
  }

  // reactivar después de un corto delay
  setTimeout(() => { intervalButtons.forEach(b => b.disabled = false); }, 700);
}

// ligar los botones al nuevo handler
intervalButtons.forEach(btn => {
  btn.addEventListener('click', () => handleIntervalGuessByName(btn));
});
  
  const playIntervalBtn = document.getElementById('playIntervalBtn');
playIntervalBtn.addEventListener('click', pickRandomInterval);

const repeatIntervalBtn = document.getElementById('repeatIntervalBtn');
const nextIntervalBtn = document.getElementById('nextIntervalBtn');

repeatIntervalBtn.addEventListener('click', (e)=>{ e.preventDefault(); if(intervalTarget) {
  // reproducir el intervalo actual
  const rootIdx = intervalTarget.rootIdx;
  const semitone = intervalTarget.semitone;
  playPreview(rootIdx, 0.6);
  setTimeout(()=> playPreview(Math.min(rootIdx+semitone, notes.length-1),0.6),650);
}});

nextIntervalBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  pickRandomInterval();
});
  
function bindPointers(){
  const allKeys = keyboardEl.querySelectorAll('.white, .black');
  allKeys.forEach(k=>{
    k.style.touchAction = 'none';
    k.addEventListener('pointerdown', ev=>{
      ev.preventDefault();
      const idx = parseInt(k.dataset.index,10);
      const rect = k.getBoundingClientRect();
      const y = ev.clientY || rect.top;
      const rel = Math.max(0, Math.min(1, (rect.bottom - y) / rect.height));
      const vel = 0.35 + rel*0.65;
      noteOn(idx, vel);
      try{ k.setPointerCapture(ev.pointerId); }catch(e){}
    });
    k.addEventListener('pointerup', ev=>{
      ev.preventDefault();
      const idx = parseInt(k.dataset.index,10);
      noteOff(idx);
      try{ k.releasePointerCapture(ev.pointerId);}catch(e){}
    });
    k.addEventListener('pointercancel', ev=> { const idx = parseInt(k.dataset.index,10); noteOff(idx); });
  });
}
setTimeout(()=>{ positionBlackKeys(); bindPointers(); }, 140);
window.addEventListener('resize', ()=> setTimeout(()=>{ positionBlackKeys(); bindPointers(); }, 80));

// keyboard mapping
const rows = [
  ['q','2','w','3','e','r','5','t','6','y','7','u','i','9','o','0','p'],
  ['a','z','s','x','d','c','f','v','g','b','h','n','j','m','k',',','.'],
  [';','/','\''] // extras
];
const flat = [].concat(...rows);
const keyMap = {}; let m=0;
for(let i=0;i<flat.length && m<notes.length;i++){ keyMap[flat[i]] = m++; }
const held = new Set();
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if(k===' '){ if(!sustainOn){ sustainOn=true; sustainBtn.textContent='Sustain: on'; sustainBtn.classList.add('primary'); } e.preventDefault(); return; }
  if(keyMap.hasOwnProperty(k) && !held.has(k)){ held.add(k); noteOn(keyMap[k], 0.95); }
});
window.addEventListener('keyup', (e)=> {
  const k = e.key.toLowerCase();
  if(k===' '){ if(sustainOn){ sustainOn=false; sustainBtn.textContent='Sustain: off'; sustainBtn.classList.remove('primary'); releaseAllHeld(); } e.preventDefault(); return; }
  if(keyMap.hasOwnProperty(k) && held.has(k)){ held.delete(k); noteOff(keyMap[k]); }
});

// reset
resetBtn.addEventListener('click', ()=> {
  const now = audioCtx.currentTime;
  activeVoices.forEach((v, key) => {
    try {
      const rel = (typeof v.release === 'number') ? v.release : 0.05;
      v.gain.gain.cancelScheduledValues(now);
      v.gain.gain.linearRampToValueAtTime(0.0001, now + rel);
      v.src.stop(now + rel + 0.05);
    } catch(e){}
  });

  setTimeout(()=>{
    activeVoices.clear();
    // limpiar visual
    const all = keyboardEl.querySelectorAll('.pressed');
    all.forEach(el => el.classList.remove('pressed'));
  }, 300);
});

// finalized
console.log('Piano (black fixed) listo — rango:', notes[0].name, '→', notes[notes.length-1].name);
</script>
</body>
  </html>
